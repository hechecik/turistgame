<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Üç Taş Ustası</title>
    <style>
        :root {
            --bg-color: #1a2533; /* Daha koyu, modern arka plan */
            --board-bg: #ecf0f1;
            --line-color: #2c3e50;
            --p1-color: #c0392b; /* Koyu Yakut Kırmızısı */
            --p1-accent: #e74c3c;
            --p2-color: #f39c12; /* Altın Sarısı */
            --p2-accent: #f1c40f;
            --text-color: #ecf0f1;
            --ui-overlay: rgba(0, 0, 0, 0.85);
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: radial-gradient(circle at center, #2c3e50, #1a2533);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 20px 10px;
            box-sizing: border-box;
            user-select: none;
            touch-action: manipulation; /* Mobilde çift dokunma zoomunu engelle */
        }

        /* Header & Scoreboard */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 400px;
            margin-bottom: 15px;
            position: relative;
        }

        h1 { margin: 0; font-size: 1.8rem; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }

        .info-btn {
            background: none; border: 2px solid rgba(255,255,255,0.5); color: white;
            width: 36px; height: 36px; border-radius: 50%; font-size: 1.2rem;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
        }

        .scoreboard {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 350px;
            margin-bottom: 15px;
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }
        .score-box {
            text-align: center; padding: 5px 15px; border-radius: 8px; transition: all 0.3s;
            opacity: 0.6;
        }
        .score-box.active { opacity: 1; transform: scale(1.05); box-shadow: 0 0 15px rgba(255,255,255,0.2); }
        .score-box span { display: block; font-size: 1.4rem; font-weight: bold; }
        .p1-color { color: var(--p1-accent); }
        .p2-color { color: var(--p2-accent); }

        /* Game Area - Responsive Container */
        .game-wrap {
            width: 100%;
            max-width: 350px; /* Maksimum genişlik */
            aspect-ratio: 1 / 1.2; /* Kareye yakın ama havuzlar için yer var */
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* The Board itself */
        .board-container {
            width: 100%;
            aspect-ratio: 1 / 1; /* Tam kare */
            position: relative;
            background-color: var(--board-bg);
            border-radius: 15px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.5);
            overflow: hidden; /* Çizgilerin taşmasını önle */
        }

        .lines-svg {
            width: 100%; height: 100%; position: absolute; top: 0; left: 0; pointer-events: none;
        }
        .lines-svg line { stroke: var(--line-color); stroke-width: 4%; stroke-linecap: round; }

        /* Spots (Drop Zones) - Percent based positioning */
        .spot {
            position: absolute; width: 20%; height: 20%;
            transform: translate(-50%, -50%); border-radius: 50%;
            z-index: 5; /* Taşların altında, çizgilerin üstünde */
            /* background: rgba(0,255,0,0.1); Debug için */
        }

        /* Pieces */
        .piece {
            width: 16%; /* Board genişliğine göre */
            aspect-ratio: 1 / 1;
            border-radius: 50%;
            position: absolute;
            z-index: 10;
            cursor: grab;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 5px 10px rgba(0,0,0,0.4);
            touch-action: none; /* Mobilde sürüklerken sayfanın kaymasını önler */
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .piece:active { cursor: grabbing; transform: scale(1.1) !important; z-index: 100; box-shadow: 0 10px 20px rgba(0,0,0,0.5); }

        /* Red Piece Design (Ruby/Gemstone) */
        .piece.red {
            background: radial-gradient(circle at 30% 30%, var(--p1-accent), var(--p1-color));
            border: 3px solid #922b21;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.3), 0 5px 10px rgba(0,0,0,0.4);
        }
        /* Yellow Piece Design (Gold Coin) */
        .piece.yellow {
            background: radial-gradient(circle at 30% 30%, #ffeead, var(--p2-color));
            border: 3px solid #d35400;
            color: #d35400; font-size: 1.5rem;
        }
        .piece.yellow::after { content: "★"; }

        /* Piece Pools */
        .pools-container {
            display: flex; justify-content: space-between; width: 100%;
            margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 15px;
        }
        .pool {
            width: 45%; height: 60px; display: flex; justify-content: center; align-items: center; gap: 5px;
            position: relative; /* Taşların relative konumlanması için */
        }

        /* Controls Menu */
        .controls-menu {
            margin-top: 20px; display: flex; flex-direction: column; gap: 10px; width: 100%; max-width: 300px;
        }
        .btn {
            padding: 12px; border: none; border-radius: 8px; font-size: 1rem; font-weight: bold; cursor: pointer;
            transition: background 0.2s, transform 0.1s; color: white;
        }
        .btn:active { transform: scale(0.98); }
        .btn-restart { background-color: #2ecc71; } .btn-restart:hover { background-color: #27ae60; }
        .btn-reset-score { background-color: #e74c3c; font-size: 0.9rem; } .btn-reset-score:hover { background-color: #c0392b; }

        /* Modals (Rules & Game Over) */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--ui-overlay); display: none;
            align-items: center; justify-content: center; z-index: 1000;
            backdrop-filter: blur(5px);
            padding: 20px; box-sizing: border-box;
        }
        .modal-content {
            background: var(--bg-color); color: var(--text-color);
            padding: 25px; border-radius: 15px; max-width: 400px; width: 100%;
            text-align: center; border: 2px solid rgba(255,255,255,0.1);
        }
        .modal-content h2 { margin-top: 0; color: var(--p2-accent); }
        .rules-list { text-align: left; margin: 15px 0; padding-left: 20px; line-height: 1.5; }
        .modal-close-btn {
            background: #34495e; margin-top: 15px; width: 100%;
        }

    </style>
</head>
<body>

    <div class="header">
        <h1>Üç Taş Ustası</h1>
        <button class="info-btn" onclick="toggleRules(true)">i</button>
    </div>

    <div class="scoreboard">
        <div id="p1-box" class="score-box p1-color active">Kırmızı<span id="score-red">0</span></div>
        <div id="p2-box" class="score-box p2-color">Sarı<span id="score-yellow">0</span></div>
    </div>

    <div class="game-wrap">
        <div class="board-container" id="board-container">
            <svg class="lines-svg" viewBox="0 0 300 300">
                <line x1="20" y1="20" x2="280" y2="20" />
                <line x1="280" y1="20" x2="280" y2="280" />
                <line x1="280" y1="280" x2="20" y2="280" />
                <line x1="20" y1="280" x2="20" y2="20" />
                <line x1="150" y1="20" x2="150" y2="280" />
                <line x1="20" y1="150" x2="280" y2="150" />
                <line x1="20" y1="20" x2="280" y2="280" />
                <line x1="280" y1="20" x2="20" y2="280" />
            </svg>
            </div>

        <div class="pools-container">
            <div class="pool" id="pool-red"></div>
            <div class="pool" id="pool-yellow"></div>
        </div>
    </div>

    <div class="controls-menu">
        <button class="btn btn-restart" onclick="startNewGameConfirm()">Yeni Oyun Başlat</button>
        <button class="btn btn-reset-score" onclick="resetScoresConfirm()">Skorları Sıfırla</button>
    </div>

    <div class="modal-overlay" id="gameover-modal">
        <div class="modal-content">
            <h2 id="gameover-msg">Oyun Bitti!</h2>
            <button class="btn btn-restart modal-close-btn" onclick="startNewGame()">Tekrar Oyna</button>
        </div>
    </div>

    <div class="modal-overlay" id="rules-modal" style="display: none;">
        <div class="modal-content">
            <h2>Nasıl Oynanır?</h2>
            <ul class="rules-list">
                <li><strong>Amaç:</strong> Yatay, dikey veya çapraz olarak 3 taşını yan yana getirmek.</li>
                <li><strong>Aşama 1 (Yerleştirme):</strong> Oyuncular sırayla ellerindeki 3 taşı boş noktalara koyar.</li>
                <li><strong>Aşama 2 (Hareket):</strong> Tüm taşlar konunca, sırası gelen oyuncu bir taşını çizgiler üzerinden *sadece* bitişik boş bir noktaya kaydırır.</li>
                <li><strong>Tıkanma:</strong> Sırası gelen oyuncunun hareket ettirecek hiçbir taşı yoksa oyun <strong>berabere</strong> biter.</li>
            </ul>
            <button class="btn modal-close-btn" onclick="toggleRules(false)">Anladım</button>
        </div>
    </div>

<script>
    // --- OYUN DEĞİŞKENLERİ ---
    const boardContainer = document.getElementById('board-container');
    const poolRed = document.getElementById('pool-red');
    const poolYellow = document.getElementById('pool-yellow');
    const gameOverModal = document.getElementById('gameover-modal');
    const rulesModal = document.getElementById('rules-modal');
    const gameOverMsg = document.getElementById('gameover-msg');
    
    let gameState = Array(9).fill(null);
    let currentPlayer = 'R'; // R (Red) başlar
    let phase = 'placing'; // 'placing' veya 'moving'
    let piecesInPlay = { R: 0, Y: 0 }; // Sahadaki veya havuza konmuş toplam taş
    let scores = { R: 0, Y: 0 };
    let isGameActive = true;

    // Pozisyonlar (Yüzde olarak - Sol, Üst)
    const posPercent = [
        {l: 10, t: 10}, {l: 50, t: 10}, {l: 90, t: 10},
        {l: 10, t: 50}, {l: 50, t: 50}, {l: 90, t: 50},
        {l: 10, t: 90}, {l: 50, t: 90}, {l: 90, t: 90}
    ];

    // Komşuluk Listesi (Hangi noktadan hangisine gidilebilir)
    // Merkez (4) her yere, köşeler (0,2,6,8) 3 yere, kenar ortalar (1,3,5,7) 3 yere bağlıdır.
    const adjacency = [
        [1, 3, 4],       // 0 (Sol Üst)
        [0, 2, 4],       // 1 (Üst Orta)
        [1, 5, 4],       // 2 (Sağ Üst)
        [0, 4, 6],       // 3 (Sol Orta)
        [0, 1, 2, 3, 5, 6, 7, 8], // 4 (Merkez)
        [2, 4, 8],       // 5 (Sağ Orta)
        [3, 4, 7],       // 6 (Sol Alt)
        [6, 4, 8],       // 7 (Alt Orta)
        [4, 5, 7]        // 8 (Sağ Alt)
    ];

    // Kazanma Kombinasyonları
    const winLines = [
        [0,1,2], [3,4,5], [6,7,8], // Yatay
        [0,3,6], [1,4,7], [2,5,8], // Dikey
        [0,4,8], [2,4,6]           // Çapraz
    ];

    // --- BAŞLATMA FONKSİYONLARI ---
    function initGame() {
        createBoardSpots();
        setupInitialPieces();
        updateUI();
    }

    function createBoardSpots() {
        // Eski noktaları temizle (restart için)
        const oldSpots = boardContainer.querySelectorAll('.spot');
        oldSpots.forEach(s => s.remove());

        posPercent.forEach((pos, index) => {
            let s = document.createElement('div');
            s.className = 'spot';
            s.style.left = pos.l + '%';
            s.style.top = pos.t + '%';
            s.dataset.index = index;
            boardContainer.appendChild(s);
        });
    }

    function setupInitialPieces() {
        // Havuzları temizle
        poolRed.innerHTML = '';
        poolYellow.innerHTML = '';
        // Boarddaki eski taşları temizle
        const boardPieces = boardContainer.querySelectorAll('.piece');
        boardPieces.forEach(p => p.remove());

        for(let i=0; i<3; i++) createPiece('R', i, poolRed);
        for(let i=0; i<3; i++) createPiece('Y', i, poolYellow);

        gameState.fill(null);
        piecesInPlay = { R: 0, Y: 0 };
        phase = 'placing';
        currentPlayer = 'R';
        isGameActive = true;
        gameOverModal.style.display = 'none';
    }

    function createPiece(type, id, container) {
        let p = document.createElement('div');
        p.className = `piece ${type === 'R' ? 'red' : 'yellow'}`;
        p.id = `${type}-${id}`;
        p.dataset.type = type;
        p.dataset.spotIndex = -1; // -1: Havuzda
        
        // Touch ve Mouse olaylarını ayırıyoruz
        p.addEventListener('touchstart', handleTouchStart, { passive: false });
        p.addEventListener('mousedown', handleMouseDown);

        // Havuzda relative pozisyon
        p.style.position = 'relative';
        p.style.left = 'auto';
        p.style.top = 'auto';
        p.style.transform = 'none';
        
        container.appendChild(p);
    }

    // --- SÜRÜKLE BIRAK SİSTEMİ (Unified Touch/Mouse) ---
    let draggedPiece = null;
    let startDragInfo = {};

    function handleTouchStart(e) { handleDragStart(e, e.touches[0]); }
    function handleMouseDown(e) { handleDragStart(e, e); }

    function handleDragStart(e, inputPoint) {
        if (!isGameActive) return;
        const piece = e.target.closest('.piece');
        if (!piece || piece.dataset.type !== currentPlayer) return;
        
        e.preventDefault(); // Scrolling'i önle

        draggedPiece = piece;
        const rect = piece.getBoundingClientRect();
        const currentSpotIdx = parseInt(piece.dataset.spotIndex);

        // Kural Kontrolü: Yerleştirme aşamasında sahadaki taşa dokunamazsın
        if (phase === 'placing' && currentSpotIdx !== -1) {
            draggedPiece = null; return;
        }

        startDragInfo = {
            piecesParent: piece.parentElement,
            startX: rect.left,
            startY: rect.top,
            inputStartX: inputPoint.clientX,
            inputStartY: inputPoint.clientY,
            spotIndex: currentSpotIdx
        };

        // Taşı body'e alıp fixed yaparak her şeyin üstüne çıkarıyoruz
        piece.style.position = 'fixed';
        piece.style.left = rect.left + 'px';
        piece.style.top = rect.top + 'px';
        piece.style.zIndex = 1000;
        document.body.appendChild(piece);

        if(e.type === 'touchstart') {
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleDragEnd);
        } else {
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleDragEnd);
        }
    }

    function handleTouchMove(e) { handleDragMove(e, e.touches[0]); }
    function handleMouseMove(e) { handleDragMove(e, e); }

    function handleDragMove(e, inputPoint) {
        if (!draggedPiece) return;
        e.preventDefault();
        const deltaX = inputPoint.clientX - startDragInfo.inputStartX;
        const deltaY = inputPoint.clientY - startDragInfo.inputStartY;
        draggedPiece.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
    }

    function handleDragEnd(e) {
        if (!draggedPiece) return;
        
        // Event listenerları temizle
        document.removeEventListener('touchmove', handleTouchMove);
        document.removeEventListener('touchend', handleDragEnd);
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleDragEnd);

        const droppedSpotIndex = getClosestSpotIndex(draggedPiece);
        let moveValid = false;

        if (droppedSpotIndex !== -1) {
            // Hedef nokta boş mu? (EN ÖNEMLİ KONTROL)
            if (gameState[droppedSpotIndex] === null) {
                if (phase === 'placing') {
                    // Yerleştirme: Sadece havuzdan geliyorsa
                    if (startDragInfo.spotIndex === -1) moveValid = true;
                } else {
                    // Hareket: Komşu mu?
                    if (startDragInfo.spotIndex !== -1 && adjacency[startDragInfo.spotIndex].includes(droppedSpotIndex)) {
                        moveValid = true;
                    }
                }
            }
        }

        if (moveValid) {
            finalizeMove(draggedPiece, startDragInfo.spotIndex, droppedSpotIndex);
        } else {
            cancelMove(draggedPiece);
        }
        draggedPiece = null;
    }

    // En yakın noktayı bul (Çarpışma testi)
    function getClosestSpotIndex(piece) {
        const pieceRect = piece.getBoundingClientRect();
        const pieceCenter = { x: pieceRect.left + pieceRect.width/2, y: pieceRect.top + pieceRect.height/2 };
        
        let closestIdx = -1;
        // Board boyutuna göre dinamik yakalama mesafesi (örneğin board genişliğinin %15'i)
        let minDistance = boardContainer.offsetWidth * 0.15; 

        document.querySelectorAll('.spot').forEach(spot => {
            const spotRect = spot.getBoundingClientRect();
            const spotCenter = { x: spotRect.left + spotRect.width/2, y: spotRect.top + spotRect.height/2 };
            const dist = Math.hypot(pieceCenter.x - spotCenter.x, pieceCenter.y - spotCenter.y);
            
            if (dist < minDistance) {
                minDistance = dist;
                closestIdx = parseInt(spot.dataset.index);
            }
        });
        return closestIdx;
    }

    function cancelMove(piece) {
        // Eski yerine (havuza veya boarddaki yerine) geri koy
        piece.style.position = startDragInfo.piecesParent.classList.contains('pool') ? 'relative' : 'absolute';
        piece.style.left = startDragInfo.piecesParent.classList.contains('pool') ? 'auto' : posPercent[startDragInfo.spotIndex].l + '%';
        piece.style.top = startDragInfo.piecesParent.classList.contains('pool') ? 'auto' : posPercent[startDragInfo.spotIndex].t + '%';
        piece.style.transform = 'translate(-50%, -50%)';
        piece.style.zIndex = 10;
        if(startDragInfo.piecesParent.classList.contains('pool')) piece.style.transform = 'none'; // Havuzda centerlama yok

        startDragInfo.piecesParent.appendChild(piece);
    }

    function finalizeMove(piece, fromIdx, toIdx) {
        // Game State Güncelle
        if (fromIdx !== -1) gameState[fromIdx] = null;
        gameState[toIdx] = currentPlayer;
        
        // DOM Güncelle
        piece.dataset.spotIndex = toIdx;
        piece.style.position = 'absolute';
        piece.style.left = posPercent[toIdx].l + '%';
        piece.style.top = posPercent[toIdx].t + '%';
        piece.style.transform = 'translate(-50%, -50%)';
        piece.style.zIndex = 10;
        boardContainer.appendChild(piece); // Board'un içine taşı

        // Yerleştirme sayacı
        if (fromIdx === -1 && phase === 'placing') piecesInPlay[currentPlayer]++;

        // KAZANMA KONTROLÜ
        if (checkWin()) {
            endGame(`${currentPlayer === 'R' ? 'Kırmızı' : 'Sarı'} Kazandı!`);
            scores[currentPlayer]++;
            updateUI();
            return;
        }

        // FAZ KONTROLÜ
        if (phase === 'placing' && piecesInPlay.R === 3 && piecesInPlay.Y === 3) {
            phase = 'moving';
        }

        // SIRA DEĞİŞTİR
        currentPlayer = currentPlayer === 'R' ? 'Y' : 'R';
        updateUI();

        // TIKANMA (BERABERLİK) KONTROLÜ - Sadece hareket aşamasında ve sıra değiştikten sonra yapılır
        if (phase === 'moving' && checkDrawStatus()) {
             endGame("Oyun Tıkandı! Berabere.");
             return;
        }
    }

    // --- OYUN MANTIĞI KONTROLLERİ ---
    function checkWin() {
        return winLines.some(line => {
            return line.every(idx => gameState[idx] === currentPlayer);
        });
    }

    // Tıkanma Kontrolü: Sırası gelen oyuncunun yapacak hamlesi var mı?
    function checkDrawStatus() {
        // 1. Şu anki oyuncunun taşlarının yerlerini bul
        let playerPiecesIndices = [];
        gameState.forEach((owner, idx) => {
            if(owner === currentPlayer) playerPiecesIndices.push(idx);
        });

        // 2. Her bir taşı için boş komşu var mı diye bak
        for (let i = 0; i < playerPiecesIndices.length; i++) {
            const currentPos = playerPiecesIndices[i];
            const neighbors = adjacency[currentPos];
            for (let j = 0; j < neighbors.length; j++) {
                // Eğer bir tane bile boş komşu bulursak oyun tıkanmamıştır.
                if (gameState[neighbors[j]] === null) {
                    return false; // Hamle var, devam et.
                }
            }
        }
        // 3. Hiçbir taş için boş komşu bulunamadıysa oyun tıkanmıştır.
        return true;
    }

    function endGame(message) {
        isGameActive = false;
        gameOverMsg.innerText = message;
        gameOverModal.style.display = 'flex';
    }

    // --- UI GÜNCELLEMELERİ ---
    function updateUI() {
        document.getElementById('score-red').innerText = scores.R;
        document.getElementById('score-yellow').innerText = scores.Y;
        document.getElementById('p1-box').classList.toggle('active', currentPlayer === 'R' && isGameActive);
        document.getElementById('p2-box').classList.toggle('active', currentPlayer === 'Y' && isGameActive);
    }

    // --- MENÜ FONKSİYONLARI ---
    function toggleRules(show) {
        rulesModal.style.display = show ? 'flex' : 'none';
    }

    function startNewGameConfirm() {
        if(confirm("Mevcut oyun sonlandırılıp yeni oyun başlatılacak. Emin misin?")) {
            startNewGame();
        }
    }
    
    function startNewGame() {
        setupInitialPieces();
        updateUI();
    }

    function resetScoresConfirm() {
        if(confirm("Tüm skorlar sıfırlanacak. Emin misin?")) {
            scores = { R: 0, Y: 0 };
            startNewGame();
        }
    }

    // Oyunu Başlat
    // Sayfa yüklendiğinde fontların vs. oturması için kısa bir gecikme ile başlatmak bazen iyidir.
    setTimeout(initGame, 100);

</script>
</body>
</html>
